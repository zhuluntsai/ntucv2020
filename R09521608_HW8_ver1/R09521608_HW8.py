#hw8
#R09521608 土木系電輔組 蔡瑋倫

# Write a program which does:
# (a) Generate noisy images with gaussian noise(amplitude of 10 and 30)
# (b) Generate noisy images with salt-and-pepper noise( probability 0.1 and 0.05)
# (c) Use the 3x3, 5x5 box filter on images generated by (a)(b)
# (d) Use 3x3, 5x5 median filter on images generated by (a)(b)
# (e) Use both opening-then-closing and closing-then-opening filter (using the octogonal 3-5-5-5-3 kernel, value = 0) on images generated by (a)(b)
# You must calculate the signal-to-ratio (SNR) for each instance(4 noisy images and 24 processed images)

from PIL import Image
import numpy as np
import random, math, csv, os

filename = 'lena.bmp'

img = Image.open(filename)
width, height = img.size

kernel = np.array([
    [0, 1, 1, 1, 0],                 
    [1, 1, 1, 1, 1], 
    [1, 1, 1, 1, 1], 
    [1, 1, 1, 1, 1], 
    [0, 1, 1, 1, 0]])
kernel_center = [int(kernel.shape[0]/2), int(kernel.shape[1]/2)]


def padding(img, padding_pixel):
    width, height = img.size
    new_image = Image.new('L', (width+padding_pixel*2, height+padding_pixel*2))
    for x in range(0, width, 1):
        for y in range(0, height, 1):
            new_image.putpixel((x+padding_pixel, y+padding_pixel), img.getpixel((x, y)))

    # padding edge
    for y in range(padding_pixel):
        for x in range(width):
            new_image.putpixel((x+padding_pixel, y), img.getpixel((x, 0)))
            new_image.putpixel((x+padding_pixel, y+height+padding_pixel), img.getpixel((x, height-1)))
    for x in range(padding_pixel):
        for y in range(height + padding_pixel):
            new_image.putpixel((x, y), new_image.getpixel((padding_pixel, y)))
            new_image.putpixel((x+width+padding_pixel, y), new_image.getpixel((width+padding_pixel-1, y)))
 
    return new_image

def guassian_noise(img, amplitude):
    new_image = Image.new('L', img.size)
    for x in range(0, width, 1):
        for y in range(0, height, 1):

            noisePixel = int(img.getpixel((x, y)) + amplitude * random.gauss(0, 1))
            if noisePixel > 255:
                noisePixel = 255
            elif noisePixel < 0:
                noisePixel = 0
            new_image.putpixel((x, y), noisePixel)
    return new_image

def salt_and_pepper(img, probability):
    new_image = Image.new('L', img.size)
    for x in range(0, width, 1):
        for y in range(0, height, 1):
            random_num = random.uniform(0, 1)
            if random_num < probability:
                new_image.putpixel((x, y), 0)
            elif random_num > 1 - probability:
                new_image.putpixel((x, y), 255)
            else:
                new_image.putpixel((x, y), img.getpixel((x, y)))
    return new_image

def box_filter(img, kernel_width, kernel_height, padding_pixel):
    new_image = Image.new('L', img.size)
    img = padding(img, padding_pixel)
    kernel_center = [int(kernel_width/2), int(kernel_height/2)]
    for x in range(padding_pixel, width+padding_pixel, 1):
        for y in range(padding_pixel, height+padding_pixel, 1):

            kernel_list = []
            for i in range(kernel_width):
                for j in range(kernel_height):
                    put_pixel_x = x + i - kernel_center[0]
                    put_pixel_y = y + j - kernel_center[1]
                    kernel_list.append(img.getpixel((put_pixel_x, put_pixel_y)))
            
            new_image.putpixel((x-padding_pixel, y-padding_pixel), int(sum(kernel_list) / len(kernel_list)))
    return new_image

def median_filter(img, kernel_width, kernel_height, padding_pixel):
    new_image = Image.new('L', img.size)
    img = padding(img, padding_pixel)
    kernel_center = [int(kernel_width/2), int(kernel_height/2)]
    for x in range(padding_pixel, width+padding_pixel, 1):
        for y in range(padding_pixel, height+padding_pixel, 1):

            kernel_list = []
            for i in range(kernel_width):
                for j in range(kernel_height):
                    put_pixel_x = x + i - kernel_center[0]
                    put_pixel_y = y + j - kernel_center[1]
                    kernel_list.append(img.getpixel((put_pixel_x, put_pixel_y)))
            kernel_list.sort()
            new_image.putpixel((x-padding_pixel, y-padding_pixel), kernel_list[int(len(kernel_list)/2)])
    return new_image

def dilation(img, kernel, kernel_center, padding_pixel):
    new_image = Image.new('L', img.size)
    img = padding(img, padding_pixel)
    for x in range(padding_pixel, width + padding_pixel, 1):
        for y in range(padding_pixel, height + padding_pixel, 1):
            pixel = img.getpixel((x, y))

            kernel_list = []
            for i in range(0, kernel.shape[0], 1):
                for j in range(0, kernel.shape[1], 1):
                    if kernel[i, j] == 1:
                        put_pixel_x = x + i - kernel_center[0]
                        put_pixel_y = y + j - kernel_center[1]
                        try:
                            kernel_list.append(img.getpixel((put_pixel_x, put_pixel_y)))
                        except:
                            pass
            
            new_image.putpixel((x - padding_pixel, y - padding_pixel), max(kernel_list))
    
    return new_image

def erosion(img, kernel, kernel_center, padding_pixel):
    new_image = Image.new('L', img.size)
    img = padding(img, padding_pixel)
    for x in range(padding_pixel, width + padding_pixel, 1):
        for y in range(padding_pixel, height + padding_pixel, 1):
            
            kernel_list = []
            for i in range(0, kernel.shape[0], 1):
                for j in range(0, kernel.shape[1], 1):
                    if kernel[i, j] == 1:
                        put_pixel_x = x + i - kernel_center[0]
                        put_pixel_y = y + j - kernel_center[1]
                        try:
                            kernel_list.append(img.getpixel((put_pixel_x, put_pixel_y)))
                        except:
                            pass

            new_image.putpixel((x - padding_pixel, y - padding_pixel), min(kernel_list))                
    
    return new_image

def opening(img, kernel, kernel_center, padding_pixel):
    new_image = dilation(erosion(img, kernel, kernel_center, padding_pixel), kernel, kernel_center, padding_pixel)
    return new_image

def closing(img, kernel, kernel_center, padding_pixel):
    new_image = erosion(dilation(img, kernel, kernel_center, padding_pixel), kernel, kernel_center, padding_pixel)
    return new_image

def opening_then_closing(img, kernel, kernel_center, padding_pixel):
    return closing(opening(img, kernel, kernel_center, padding_pixel), kernel, kernel_center, padding_pixel)

def closing_then_opening(img, kernel, kernel_center, padding_pixel):
    return opening(closing(img, kernel, kernel_center, padding_pixel), kernel, kernel_center, padding_pixel)

def SNR(img, noise_image):
    mu_s = 0
    vs = 0
    mu_noise = 0
    vn = 0

    for x in range(0, width, 1):
        for y in range(0, height, 1):
            mu_s += img.getpixel((x, y))
            mu_noise += noise_image.getpixel((x, y)) - img.getpixel((x, y))
    mu_s = mu_s / (width * height) / 255
    mu_noise = mu_noise / (width * height) / 255

    for x in range(0, width, 1):
        for y in range(0, height, 1):
            vs += (img.getpixel((x, y))/255 - mu_s)**2
            vn += (noise_image.getpixel((x, y))/255 - img.getpixel((x, y))/255 - mu_noise)**2
    vs = vs / (width * height)
    vn = vn / (width * height)

    snr = 20 * math.log10(math.sqrt(vs) / math.sqrt(vn))
    return snr

for amplitude in [10, 30]:
    guassian_noise_img = guassian_noise(img, amplitude)
    guassian_noise_img.save(f'guassian_noise_{amplitude}_{filename}')
    for kernel_size in [3, 5]:
        box_filter(guassian_noise_img, kernel_size, kernel_size, 2).save(f'guassian_noise_{amplitude}_box_filter_{kernel_size}x{kernel_size}_{filename}')
        median_filter(guassian_noise_img, kernel_size, kernel_size, 2).save(f'guassian_noise_{amplitude}_median_filter_{kernel_size}x{kernel_size}_{filename}')
    opening_then_closing(guassian_noise_img, kernel, kernel_center, 2).save(f'guassian_noise_{amplitude}_opening_then_closing_{filename}')
    closing_then_opening(guassian_noise_img, kernel, kernel_center, 2).save(f'guassian_noise_{amplitude}_closing_then_opening_{filename}')

for probability in [0.1, 0.05]:
    salt_and_pepper_img = salt_and_pepper(img, probability)
    salt_and_pepper_img.save(f'salt_and_pepper_{probability}_{filename}')
    for kernel_size in [3, 5]:
        box_filter(salt_and_pepper_img, kernel_size, kernel_size, 2).save(f'salt_and_pepper_{probability}_box_filter_{kernel_size}x{kernel_size}_{filename}')
        median_filter(salt_and_pepper_img, kernel_size, kernel_size, 2).save(f'salt_and_pepper_{probability}_median_filter_{kernel_size}x{kernel_size}_{filename}')
    opening_then_closing(salt_and_pepper_img, kernel, kernel_center, 2).save(f'salt_and_pepper_{probability}_opening_then_closing_{filename}')
    closing_then_opening(salt_and_pepper_img, kernel, kernel_center, 2).save(f'salt_and_pepper_{probability}_closing_then_opening_{filename}')

snr_csv = open('snr.csv', 'w', newline='')
writer = csv.writer(snr_csv)
for file in os.listdir():
    if file.endswith('.bmp') and file != filename:
        writer.writerow([file[:-4], SNR(img, Image.open(file))])